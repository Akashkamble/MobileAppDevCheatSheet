Abstract
contains both concrete and abstract methods

Interface 
blueprint/contract of a class

Composition (has-a relationship)
Person {
   // Person has a job 
   Job jb;
}

Inheritance 
Animal {}
Cat extends Animal {}

Overloading (static polymorphism)
Printer{
   void display();
   void display(String message);
}

Overriding (dynamic polymorphism)
Printer{
   void print();
}

DeskJetPrinter extends Printer{
   @Override
   void print();
}

Overloading & Overriding - A different example 
Printer {
   static print() { sop("Static method of Printer") }
   printTest() { sop("Instance method of Printer") }
}

DeskJetPrinter extends Printer{
   static print() { sop("Static method of DeskJetPrinter") }
   
   @Override
   printTest() { sop("Instance method of DeskJetPrinter") }
}

main(){
   DeskJetPrinter djp = new DeskJetPrinter()
   djp.printTest()
   
   Printer prt = djp
   prt.print()
   prt.printTest()
}

Output: 
Instance method of DeskJetPrinter
Static method of Printer
Instance method of DeskJetPrinter

Access Modifiers 
private, protected, default & public 

Design Patterns 
Creational (builders, factory, Singleton, Monostate, Fluent Interface Patterns)
Structural (adapter, decorator, facade)
Behavioural(chain of responsibility, iterator & strategy)

String 
The String class is immutable, so that once it is created a String object cannot be changed,
inorder to prevent malicious manipulation of data.

String Constant Pool
When string is assigned value using "", it looks into the String Pool Constant. 
If the value exists same reference is returned else a new Constant is created and referenced is returned.

Heap Space vs String Constant Pool 
Heap Space - A space which holds objects created using new keyword 
Constant Pool - A space which holds string objects created with double quotes and non repitive 

main(){
   String s1 = "Cat"
   String s2 = "Cat"
   String s3 = new String("Cat");
        
   sop("s1 == s2 :"+(s1==s2));
   sop("s1 == s3 :"+(s1==s3));
}

Output
true 
false

String.intern()
1. checks for the same string exists in pool. 
2. if not, it is added and reference of the same is returned 

Example: 
String s1 = new String("Leo") // This goes in Java Heap [ "Leo" ] & SCP [  ] is empty 
String s2 = s1.intern()       // Checks in SCP, creates a new constant in SCP [ "Leo" ]
String s3 = "Leo"

print(s1 == s2) => false      // since both reference to different location (1 in Heap and other in constant pool)
print(s1 .equals s2) => true  // comparing values
print(s2 == s3) => true       // since both are refering to same refernce which is coming from SCP 

Collections & Generics 
Arrays, ArrayLists, HashSet, TreeSet, HashMap, HashSet, Stack, Queues.

Enumeration (forward only)
Used with legacy objects, can only read through elements and cannot make changes (add/remove)

Iterator (forward only)
Can be used with any Collections objects and rest is same as above

ListIterator (both direction)
can add/remove and travese in both direction with any list

HashSet (no order)
No duplicates, can accept single null value  
ex: HashSet {“Hello”, “Hi”, “Bye”, “Run”}

TreeSet (in order) 
same as above 

HashMap (no order)
No duplicates, can accept single null as key 
works with key & value.
ex: HashMap {1->”Hello”, 2->”Hi”, 3->”Bye”, 4->”Run”}

TreeMap (ascending order by keys)
same as above 

LinkedHashMap (maintains link order)
same as above 

Stack 
Stack => [Jack, Queen, King, Ace]
push(Leo)
pop() => Leo
peek() => Ace
Current Stack => [Jack, Queen, King]

Queue (FIFO)
add, peek, remove(removes the head)












